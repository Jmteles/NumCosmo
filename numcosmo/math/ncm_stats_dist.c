/* -*- Mode: C; indent-tabs-mode: nil; c-basic-offset: 2; tab-width: 2 -*-  */

/***************************************************************************
 *            ncm_stats_dist.c
 *
 *  Wed November 07 16:02:36 2018
 *  Copyright  2018  Sandro Dias Pinto Vitenti
 *  <sandro@isoftware.com.br>
 ****************************************************************************/
/*
 * ncm_stats_dist.c
 * Copyright (C) 2018 Sandro Dias Pinto Vitenti <sandro@isoftware.com.br>
 *
 * numcosmo is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * numcosmo is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * SECTION:ncm_stats_dist
 * @title: NcmStatsDist
 * @short_description: Abstract class for implementing N dimensional probability distributions
 *
 * Abstract class to reconstruct an arbitrary N dimensional probability distribution.
 * This object provides the tools to perform a radial basis interpolation
 * in a multidimensional function using a radial basis function.
 * The goal is to use a polynomial function generated by the interpolation,
 * such that we are able to sample the original function from this new interpolation function.
 * For more informations about radial basis interpolation,
 * check [[Radial Basis Function Interpolation, Wilna du Toit](https://core.ac.uk/download/pdf/37320748.pdf)].
 * A brief description of the radial basis interpolation method can be found below.
 *
 * Given a d-simensional function $g(x): \mathbf{R}^d \rightarrow \mathbf{R}$, a radial basis
 * function $\phi(x)$ is used such that
 * \begin{align}
 * \label{Interpolation_eq}
 * s(x) = \sum_i^n \lambda \phi(|x-xi|), \quad x~ \in~ \mathbf{R}
 *. \end{align}
 * The matrix lambda is found such that $s(x_i) = g(x_i)$, being $x_i$ the sample points.
 * The points $\phi(|x-x_i|)$ generate a symmetric $n \times n$ matrix using a radial basis function.
 * Once the Lambda matrix is found, one may use $s(x)$ to sample values from $g(x)$, which is easier to do since $s(x)$ is
 * a polynomial function.
 *
 * We want $s(x)$ to be a probability function so we can sample from it. Therefore the Lambda matrix containing the
 * weights is seen as the probability density of our probability function and it must be minimized
 * such that its values are always positive and sum up to one. To solve this problem, this algorithm has the tools to solve equation \eqref{Interpolation_eq} for $\lambda$
 * using the LowRankQP method, the NNLS method or the Libqp method.
 * These methods can be found in the LowRankQP.c, nnls.c and libqp_plx.c files respectively.
 *
 * In this file, the radial basis interpolation function is not defined. One must choose one of the instances of the class, the
 * #NcmStatsDistKDEStudentt object or the #NcmStatsDistKDEGauss object, which use a multivariate Student's t function and a Gaussian function respectively.
 * After initializing the desired object for the interpolation function, one may use the methods of this file to generate the interpolation and to
 * sample from the new interpolated function.
 *
 * The user must provide input the values: over_smooth - ncm_stats_dist_set_over_smooth(), $v(x)$ - ncm_stats_dist_prepare_interp(). The other parameters are
 * automatically calculated when the instance for the Gauss or the Student's t functions is initialized.
 *
 *
 *
 */

#ifdef HAVE_CONFIG_H
#  include "config.h"
#endif /* HAVE_CONFIG_H */
#include "build_cfg.h"

#include "math/ncm_stats_dist.h"
#include "math/ncm_iset.h"
#include "math/ncm_lapack.h"
#include "ncm_enum_types.h"

#ifndef NUMCOSMO_GIR_SCAN
#include <gsl/gsl_blas.h>
#include <gsl/gsl_min.h>
#include <gsl/gsl_multimin.h>
#include "levmar/levmar.h"
#endif /* NUMCOSMO_GIR_SCAN */

#include "math/ncm_stats_dist_private.h"

enum
{
  PROP_0,
  PROP_KERNEL,
  PROP_SAMPLE_SIZE,
  PROP_OVER_SMOOTH,
  PROP_CV_TYPE,
  PROP_SPLIT_FRAC,
};

G_DEFINE_ABSTRACT_TYPE_WITH_PRIVATE (NcmStatsDist, ncm_stats_dist, G_TYPE_OBJECT);

static void
ncm_stats_dist_init (NcmStatsDist *sd)
{
  NcmStatsDistPrivate * const self = sd->priv = ncm_stats_dist_get_instance_private (sd);
  
  self->kernel       = NULL;
  self->sample_array = g_ptr_array_new ();
  self->weights      = NULL;
  self->over_smooth  = 0.0;
  self->cv_type      = NCM_STATS_DIST_CV_LEN;
  self->split_frac   = 0.0;
  self->min_m2lnp    = 0.0;
  self->max_m2lnp    = 0.0;
  self->href         = 0.0;
  self->rnorm        = 0.0;
  self->n            = 0;
  self->alloc_n      = 0;
  self->d            = 0;
  self->sampling     = g_array_new (FALSE, FALSE, sizeof (guint));
  self->nnls         = NULL;
  self->IM           = NULL;
  self->sub_IM       = NULL;
  self->sub_x        = NULL;
  self->f            = NULL;
  self->levmar_workz = NULL;
  self->levmar_n     = 0;
  
  g_ptr_array_set_free_func (self->sample_array, (GDestroyNotify) ncm_vector_free);
}

static void
_ncm_stats_dist_set_property (GObject *object, guint prop_id, const GValue *value, GParamSpec *pspec)
{
  NcmStatsDist *sd = NCM_STATS_DIST (object);
  
  /*g_return_if_fail (NCM_IS_STATS_DIST (object));*/
  
  switch (prop_id)
  {
    case PROP_KERNEL:
      ncm_stats_dist_set_kernel (sd, g_value_get_object (value));
      break;
    case PROP_SAMPLE_SIZE:
      g_assert_not_reached ();
      break;
    case PROP_OVER_SMOOTH:
      ncm_stats_dist_set_over_smooth (sd, g_value_get_double (value));
      break;
    case PROP_CV_TYPE:
      ncm_stats_dist_set_cv_type (sd, g_value_get_enum (value));
      break;
    case PROP_SPLIT_FRAC:
      ncm_stats_dist_set_split_frac (sd, g_value_get_double (value));
      break;
    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
      break;
  }
}

static void
_ncm_stats_dist_get_property (GObject *object, guint prop_id, GValue *value, GParamSpec *pspec)
{
  NcmStatsDist *sd                 = NCM_STATS_DIST (object);
  NcmStatsDistPrivate * const self = sd->priv;
  
  g_return_if_fail (NCM_IS_STATS_DIST (object));
  
  switch (prop_id)
  {
    case PROP_KERNEL:
      g_value_set_object (value, ncm_stats_dist_peek_kernel (sd));
      break;
    case PROP_SAMPLE_SIZE:
      g_value_set_uint (value, self->sample_array->len);
      break;
    case PROP_OVER_SMOOTH:
      g_value_set_double (value, ncm_stats_dist_get_over_smooth (sd));
      break;
    case PROP_CV_TYPE:
      g_value_set_enum (value, ncm_stats_dist_get_cv_type (sd));
      break;
    case PROP_SPLIT_FRAC:
      g_value_set_double (value, ncm_stats_dist_get_split_frac (sd));
      break;
    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
      break;
  }
}

static void
_ncm_stats_dist_dispose (GObject *object)
{
  NcmStatsDist *sd                 = NCM_STATS_DIST (object);
  NcmStatsDistPrivate * const self = sd->priv;
  
  ncm_stats_dist_kernel_clear (&self->kernel);
  
  g_clear_pointer (&self->sample_array, g_ptr_array_unref);
  ncm_vector_clear (&self->weights);
  
  g_clear_pointer (&self->sampling, g_array_unref);
  
  ncm_nnls_clear (&self->nnls);
  
  ncm_matrix_clear (&self->IM);
  ncm_matrix_clear (&self->sub_IM);
  ncm_vector_clear (&self->sub_x);
  ncm_vector_clear (&self->f);
  
  /* Chain up : end */
  G_OBJECT_CLASS (ncm_stats_dist_parent_class)->dispose (object);
}

static void
_ncm_stats_dist_finalize (GObject *object)
{
  NcmStatsDist *sd                 = NCM_STATS_DIST (object);
  NcmStatsDistPrivate * const self = sd->priv;
  
  self->levmar_n = 0;
  g_clear_pointer (&self->levmar_workz, g_free);
  
  /* Chain up : end */
  G_OBJECT_CLASS (ncm_stats_dist_parent_class)->finalize (object);
}

static void _ncm_stats_dist_set_dim (NcmStatsDist *sd, const guint dim);
static gdouble _ncm_stats_dist_get_href (NcmStatsDist *sd);

static void
_ncm_stats_dist_prepare_kernel (NcmStatsDist *sd, GPtrArray *sample_array)
{
  g_error ("method prepare_kernel not implemented by %s.", G_OBJECT_TYPE_NAME (sd));
}

static void _ncm_stats_dist_prepare (NcmStatsDist *sd);
static void _ncm_stats_dist_prepare_interp (NcmStatsDist *sd, NcmVector *m2lnp);

static void
_ncm_stats_dist_compute_IM (NcmStatsDist *sd, NcmMatrix *IM)
{
  g_error ("method compute_IM not implemented by %s.", G_OBJECT_TYPE_NAME (sd));
}

static NcmMatrix *
_ncm_stats_dist_peek_cov_decomp (NcmStatsDist *sd, guint i)
{
  g_error ("method peek_cov_decomp not implemented by %s.", G_OBJECT_TYPE_NAME (sd));
  
  return NULL;
}

static gdouble
_ncm_stats_dist_get_lnnorm (NcmStatsDist *sd, guint i)
{
  g_error ("method get_lnnorm not implemented by %s.", G_OBJECT_TYPE_NAME (sd));
  
  return 0.0;
}

static gdouble
_ncm_stats_dist_eval_weights (NcmStatsDist *sd, NcmVector *weights, NcmVector *x)
{
  g_error ("method eval_weights not implemented by %s.", G_OBJECT_TYPE_NAME (sd));
  
  return 0.0;
}

static gdouble
_ncm_stats_dist_eval_weights_m2lnp (NcmStatsDist *sd, NcmVector *weights, NcmVector *x)
{
  g_error ("method eval_weights_m2lnp not implemented by %s.", G_OBJECT_TYPE_NAME (sd));
  
  return 0.0;
}

static void _ncm_stats_dist_reset (NcmStatsDist *sd);

static void
ncm_stats_dist_class_init (NcmStatsDistClass *klass)
{
  GObjectClass *object_class = G_OBJECT_CLASS (klass);
  
  object_class->set_property = &_ncm_stats_dist_set_property;
  object_class->get_property = &_ncm_stats_dist_get_property;
  object_class->dispose      = &_ncm_stats_dist_dispose;
  object_class->finalize     = &_ncm_stats_dist_finalize;
  
  g_object_class_install_property (object_class,
                                   PROP_KERNEL,
                                   g_param_spec_object ("kernel",
                                                        NULL,
                                                        "Interpolating kernel",
                                                        NCM_TYPE_STATS_DIST_KERNEL,
                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | G_PARAM_STATIC_NAME | G_PARAM_STATIC_BLURB));
  g_object_class_install_property (object_class,
                                   PROP_SAMPLE_SIZE,
                                   g_param_spec_uint ("N",
                                                      NULL,
                                                      "sample size",
                                                      0, G_MAXUINT, 0,
                                                      G_PARAM_READABLE | G_PARAM_STATIC_NAME | G_PARAM_STATIC_BLURB));
  
  g_object_class_install_property (object_class,
                                   PROP_OVER_SMOOTH,
                                   g_param_spec_double ("over-smooth",
                                                        NULL,
                                                        "Over-smooth distribution",
                                                        1.0e-5, G_MAXDOUBLE, 1.0,
                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT | G_PARAM_STATIC_NAME | G_PARAM_STATIC_BLURB));
  
  g_object_class_install_property (object_class,
                                   PROP_CV_TYPE,
                                   g_param_spec_enum ("CV-type",
                                                      NULL,
                                                      "Cross-validation method",
                                                      NCM_TYPE_STATS_DIST_CV, NCM_STATS_DIST_CV_NONE,
                                                      G_PARAM_READWRITE | G_PARAM_CONSTRUCT | G_PARAM_STATIC_NAME | G_PARAM_STATIC_BLURB));
  g_object_class_install_property (object_class,
                                   PROP_SPLIT_FRAC,
                                   g_param_spec_double ("split-frac",
                                                        NULL,
                                                        "Fraction to use in the split cross-validation",
                                                        0.50, 0.95, 0.9,
                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT | G_PARAM_STATIC_NAME | G_PARAM_STATIC_BLURB));
  
  
  klass->set_dim            = &_ncm_stats_dist_set_dim;
  klass->get_href           = &_ncm_stats_dist_get_href;
  klass->prepare_kernel     = &_ncm_stats_dist_prepare_kernel;
  klass->prepare            = &_ncm_stats_dist_prepare;
  klass->prepare_interp     = &_ncm_stats_dist_prepare_interp;
  klass->compute_IM         = &_ncm_stats_dist_compute_IM;
  klass->peek_cov_decomp    = &_ncm_stats_dist_peek_cov_decomp;
  klass->get_lnnorm         = &_ncm_stats_dist_get_lnnorm;
  klass->eval_weights       = &_ncm_stats_dist_eval_weights;
  klass->eval_weights_m2lnp = &_ncm_stats_dist_eval_weights_m2lnp;
  klass->reset              = &_ncm_stats_dist_reset;
}

static void
_ncm_stats_dist_set_dim (NcmStatsDist *sd, const guint dim)
{
  NcmStatsDistPrivate * const self = sd->priv;
  
  self->d = dim;
}

static gdouble
_ncm_stats_dist_get_href (NcmStatsDist *sd)
{
  NcmStatsDistPrivate * const self = sd->priv;
  
  return self->over_smooth * ncm_stats_dist_kernel_get_rot_bandwidth (self->kernel, self->n);
}

static void
_ncm_stats_dist_prepare (NcmStatsDist *sd)
{
  NcmStatsDistClass *sd_class      = NCM_STATS_DIST_GET_CLASS (sd);
  NcmStatsDistPrivate * const self = sd->priv;
  
  self->n = self->sample_array->len;
  
  if (self->n <= self->d)
    g_error ("_ncm_stats_dist_prepare: sample too small.");
  
  sd_class->prepare_kernel (sd, self->sample_array);
  
  if ((self->weights == NULL) || (self->n != ncm_vector_len (self->weights)))
  {
    ncm_vector_clear (&self->weights);
    self->weights = ncm_vector_new (self->n);
  }
  
  self->href = ncm_stats_dist_get_href (sd);
  
  ncm_vector_set_all (self->weights, 1.0 / (1.0 * self->n));
}

typedef struct _NcmStatsDistEval
{
  NcmStatsDist *sd;
  NcmStatsDistPrivate * const self;
  NcmStatsDistClass *sd_class;
} NcmStatsDistEval;

static void
_ncm_stats_dist_prepare_interp_fit_nnls_f (gdouble *p, gdouble *hx, gint m, gint n, gpointer adata)
{
  NcmStatsDistEval *eval = adata;
  NcmVector *f           = ncm_vector_new_data_static (hx, n, 1);
  NcmVector *res;
  
  eval->self->over_smooth = exp (p[0]);
  eval->self->href        = ncm_stats_dist_get_href (eval->sd);
  
  eval->sd_class->compute_IM (eval->sd, eval->self->IM);
  ncm_nnls_solve (eval->self->nnls, eval->self->sub_IM, eval->self->sub_x, eval->self->f);
  
  res = ncm_nnls_get_residuals (eval->self->nnls);
  ncm_vector_memcpy (f, res);
  
  ncm_vector_free (f);
}

static void
_ncm_stats_dist_prepare_interp (NcmStatsDist *sd, NcmVector *m2lnp)
{
  NcmStatsDistPrivate * const self = sd->priv;
  
  ncm_stats_dist_prepare (sd);
  g_assert_cmpuint (ncm_vector_len (m2lnp), ==, self->n);
  {
    NcmStatsDistClass *sd_class = NCM_STATS_DIST_GET_CLASS (sd);
    NcmStatsDistEval eval       = {sd, self, sd_class};
    const gint nrows            = self->n;
    const gint ncols            = ceil (self->n * self->split_frac);
    const gdouble dbl_limit     = 1.0;
    gint i;
    
    g_assert_cmpuint (nrows, >=, ncols);
    
    /*
     * Preparing allocations
     */
    if (self->n != self->alloc_n)
    {
      ncm_matrix_clear (&self->IM);
      ncm_vector_clear (&self->f);
      
      self->IM = ncm_matrix_new (self->n, self->n);
      self->f  = ncm_vector_new (self->n);
      
      self->alloc_n = self->n;
    }
    
    if ((self->nnls == NULL) ||
        ((ncm_nnls_get_nrows (self->nnls) != nrows) || (ncm_nnls_get_ncols (self->nnls) != ncols)))
    {
      ncm_nnls_clear (&self->nnls);
      self->nnls = ncm_nnls_new (nrows, ncols);
      ncm_nnls_set_umethod (self->nnls, NCM_NNLS_UMETHOD_NORMAL);
      
      ncm_matrix_clear (&self->sub_IM);
      ncm_vector_clear (&self->sub_x);
      
      self->sub_IM = ncm_matrix_get_submatrix (self->IM, 0, 0, nrows, ncols);
      self->sub_x  = ncm_vector_get_subvector (self->weights, 0, ncols);
    }
    
    ncm_vector_set_zero (self->weights);
    
    /*
     * Evaluating the right-hand-side
     */
    self->min_m2lnp = GSL_POSINF;
    self->max_m2lnp = GSL_NEGINF;
    
    for (i = 0; i < self->n; i++)
    {
      const gdouble m2lnp_i = ncm_vector_get (m2lnp, i);
      
      self->min_m2lnp = MIN (self->min_m2lnp, m2lnp_i);
      self->max_m2lnp = MAX (self->max_m2lnp, m2lnp_i);
    }
    
    if (-0.5 * (self->max_m2lnp - self->min_m2lnp) < dbl_limit * GSL_LOG_DBL_EPSILON)
    {
      const guint fi = ncm_vector_get_min_index (m2lnp);
      
      g_assert_cmpuint (fi, <, ncm_vector_len (m2lnp));
      
      ncm_vector_set_zero (self->weights);
      ncm_vector_set (self->weights, fi, 1.0);
      
      self->href = 1.0;
      
      return;
    }
    
    for (i = 0; i < self->n; i++)
    {
      const gdouble m2lnp_i = ncm_vector_get (m2lnp, i);
      
      ncm_vector_set (self->f, i, exp (-0.5 * (m2lnp_i - self->min_m2lnp)));
    }
    
    if (self->n > 10000)
      g_warning ("_ncm_stats_dist_prepare_interp: very large system n = %u!", self->n);
    
    switch (self->cv_type)
    {
      case NCM_STATS_DIST_CV_SPLIT:
      {
        gdouble info[LM_INFO_SZ];
        gdouble opts[LM_OPTS_SZ];
        gdouble cov, ln_os;
        
        if (self->levmar_n != self->n)
        {
          g_clear_pointer (&self->levmar_workz, g_free);
          self->levmar_workz = g_new0 (gdouble, LM_DIF_WORKSZ (self->d, self->n));
        }
        
        opts[0] = LM_INIT_MU;
        opts[1] = 1.0e-7;
        opts[2] = 1.0e-7;
        opts[3] = 1.0e-10;
        opts[4] = LM_DIFF_DELTA;
        
        ln_os = log (self->over_smooth);
        
        dlevmar_dif (&_ncm_stats_dist_prepare_interp_fit_nnls_f,
                     &ln_os, NULL, 1, self->n,
                     10000, opts, info, self->levmar_workz, &cov, &eval);
        
        self->over_smooth = exp (ln_os);
        self->href        = ncm_stats_dist_get_href (sd);
        sd_class->compute_IM (sd, self->IM);
        
        self->rnorm = ncm_nnls_solve (self->nnls, self->sub_IM, self->sub_x, self->f);
      }
      break;
      case NCM_STATS_DIST_CV_NONE:
        sd_class->compute_IM (sd, self->IM);
        self->rnorm = ncm_nnls_solve (self->nnls, self->sub_IM, self->sub_x, self->f);
        break;
      default:
        g_assert_not_reached ();
        break;
    }
  }
}

static void
_ncm_stats_dist_reset (NcmStatsDist *sd)
{
  NcmStatsDistPrivate * const self = sd->priv;
  
  g_ptr_array_set_size (self->sample_array, 0);
}

/**
 * ncm_stats_dist_ref:
 * @sd: a #NcmStatsDist
 *
 * Increases the reference count of @sd.
 *
 * Returns: (transfer full): @sd.
 */
NcmStatsDist *
ncm_stats_dist_ref (NcmStatsDist *sd)
{
  return g_object_ref (sd);
}

/**
 * ncm_stats_dist_free:
 * @sd: a #NcmStatsDist
 *
 * Decreases the reference count of @sd.
 *
 */
void
ncm_stats_dist_free (NcmStatsDist *sd)
{
  g_object_unref (sd);
}

/**
 * ncm_stats_dist_clear:
 * @sd: a #NcmStatsDist
 *
 * Decreases the reference count of *@sd and sets the pointer *@sd to NULL.
 *
 */
void
ncm_stats_dist_clear (NcmStatsDist **sd)
{
  g_clear_object (sd);
}

/**
 * ncm_stats_dist_set_kernel:
 * @sd: a #NcmStatsDist
 * @sdk: a #NcmStatsDistKernel
 *
 * Sets the kernel to be used in the interpolation.
 */
void
ncm_stats_dist_set_kernel (NcmStatsDist *sd, NcmStatsDistKernel *sdk)
{
  NcmStatsDistPrivate * const self = sd->priv;
  
  ncm_stats_dist_kernel_clear (&self->kernel);
  self->kernel = ncm_stats_dist_kernel_ref (sdk);
  
  NCM_STATS_DIST_GET_CLASS (sd)->set_dim (sd, ncm_stats_dist_kernel_get_dim (sdk));
}

/**
 * ncm_stats_dist_peek_kernel:
 * @sd: a #NcmStatsDist
 *
 * Gets the kernel to be used in the interpolation.
 *
 * Returns: (transfer none): current #NcmStatsDistKernel used.
 */
NcmStatsDistKernel *
ncm_stats_dist_peek_kernel (NcmStatsDist *sd)
{
  NcmStatsDistPrivate * const self = sd->priv;
  
  return self->kernel;
}

/**
 * ncm_stats_dist_get_kernel:
 * @sd: a #NcmStatsDist
 *
 * Gets the kernel to be used in the interpolation.
 *
 * Returns: (transfer full): current #NcmStatsDistKernel used.
 */
NcmStatsDistKernel *
ncm_stats_dist_get_kernel (NcmStatsDist *sd)
{
  NcmStatsDistPrivate * const self = sd->priv;
  
  return ncm_stats_dist_kernel_ref (self->kernel);
}

/**
 * ncm_stats_dist_get_dim:
 * @sd: a #NcmStatsDist
 *
 * Returns: the dimension of the sample space.
 */
guint
ncm_stats_dist_get_dim (NcmStatsDist *sd)
{
  NcmStatsDistPrivate * const self = sd->priv;
  
  return self->d;
}

/**
 * ncm_stats_dist_get_sample_size:
 * @sd: a #NcmStatsDist
 *
 * Returns: the size of the sample used in the last prepare call.
 */
guint
ncm_stats_dist_get_sample_size (NcmStatsDist *sd)
{
  NcmStatsDistPrivate * const self = sd->priv;
  
  return self->n;
}

/**
 * ncm_stats_dist_get_href:
 * @sd: a #NcmStatsDist
 *
 * Returns: the currently used href.
 */
gdouble
ncm_stats_dist_get_href (NcmStatsDist *sd)
{
  NcmStatsDistClass *sd_class = NCM_STATS_DIST_GET_CLASS (sd);
  
  return sd_class->get_href (sd);
}

/**
 * ncm_stats_dist_set_over_smooth:
 * @sd: a #NcmStatsDist
 * @over_smooth: the over-smooth factor
 *
 * Sets the over-smooth factor to @over_smooth.
 *
 */
void
ncm_stats_dist_set_over_smooth (NcmStatsDist *sd, const gdouble over_smooth)
{
  NcmStatsDistPrivate * const self = sd->priv;
  
  self->over_smooth = over_smooth;
}

/**
 * ncm_stats_dist_get_over_smooth:
 * @sd: a #NcmStatsDist
 *
 * Returns: the over-smooth factor.
 */
gdouble
ncm_stats_dist_get_over_smooth (NcmStatsDist *sd)
{
  NcmStatsDistPrivate * const self = sd->priv;
  
  return self->over_smooth;
}

/**
 * ncm_stats_dist_set_split_frac:
 * @sd: a #NcmStatsDist
 * @split_frac: the over-smooth factor
 *
 * Sets cross-correlation split fraction to @split_frac.
 *
 */
void
ncm_stats_dist_set_split_frac (NcmStatsDist *sd, const gdouble split_frac)
{
  NcmStatsDistPrivate * const self = sd->priv;
  
  g_assert_cmpfloat (split_frac, >=, 0.5);
  g_assert_cmpfloat (split_frac, <=, 1.0);
  
  self->split_frac = split_frac;
}

/**
 * ncm_stats_dist_get_split_frac:
 * @sd: a #NcmStatsDist
 *
 * Returns: the cross-correlation split fraction.
 */
gdouble
ncm_stats_dist_get_split_frac (NcmStatsDist *sd)
{
  NcmStatsDistPrivate * const self = sd->priv;
  
  return self->split_frac;
}

/**
 * ncm_stats_dist_set_cv_type:
 * @sd: a #NcmStatsDist
 * @cv_type: a #NcmStatsDistCV
 *
 * Sets the cross-validation method to @cv_type.
 *
 */
void
ncm_stats_dist_set_cv_type (NcmStatsDist *sd, const NcmStatsDistCV cv_type)
{
  NcmStatsDistPrivate * const self = sd->priv;
  
  self->cv_type = cv_type;
}

/**
 * ncm_stats_dist_get_cv_type:
 * @sd: a #NcmStatsDist
 *
 * Returns: current cross-validation method used.
 */
NcmStatsDistCV
ncm_stats_dist_get_cv_type (NcmStatsDist *sd)
{
  NcmStatsDistPrivate * const self = sd->priv;
  
  return self->cv_type;
}

/**
 * ncm_stats_dist_prepare: (virtual prepare)
 * @sd: a #NcmStatsDist
 *
 * Prepares the object for calculations.
 */
void
ncm_stats_dist_prepare (NcmStatsDist *sd)
{
  NcmStatsDistClass *sd_class = NCM_STATS_DIST_GET_CLASS (sd);
  
  sd_class->prepare (sd);
}

/**
 * ncm_stats_dist_prepare_interp: (virtual prepare_interp)
 * @sd: a #NcmStatsDist
 * @m2lnp: a #NcmVector containing the distribution values
 *
 * Prepares the object for calculations. Using the distribution values
 * at the sample points.
 *
 */
void
ncm_stats_dist_prepare_interp (NcmStatsDist *sd, NcmVector *m2lnp)
{
  NcmStatsDistClass *sd_class = NCM_STATS_DIST_GET_CLASS (sd);
  
  sd_class->prepare_interp (sd, m2lnp);
}

/**
 * ncm_stats_dist_eval:
 * @sd: a #NcmStatsDist
 * @x: a #NcmVector
 *
 * Evaluate the distribution at $\vec{x}=$@x. If the distribution
 * was prepared using ncm_stats_dist_prepare_interp(), the
 * results will follow the interpolation and may not be properly
 * normalized. In this case the method ncm_stats_dist_eval_m2lnp()
 * should be used to avoid underflow.
 *
 * Returns: $P(\vec{x})$.
 */
gdouble
ncm_stats_dist_eval (NcmStatsDist *sd, NcmVector *x)
{
  NcmStatsDistClass *sd_class      = NCM_STATS_DIST_GET_CLASS (sd);
  NcmStatsDistPrivate * const self = sd->priv;
  
  return sd_class->eval_weights (sd, self->weights, x);
}

/**
 * ncm_stats_dist_eval_m2lnp:
 * @sd: a #NcmStatsDist
 * @x: a #NcmVector
 *
 * Evaluate the distribution at $\vec{x}=$@x. If the distribution
 * was prepared using ncm_stats_dist_prepare_interp(), the
 * results will follow the interpolation and may not be properly
 * normalized.
 *
 * Returns: $P(\vec{x})$.
 */
gdouble
ncm_stats_dist_eval_m2lnp (NcmStatsDist *sd, NcmVector *x)
{
  NcmStatsDistClass *sd_class      = NCM_STATS_DIST_GET_CLASS (sd);
  NcmStatsDistPrivate * const self = sd->priv;
  
  return sd_class->eval_weights_m2lnp (sd, self->weights, x);
}

/**
 * ncm_stats_dist_sample:
 * @sd: a #NcmStatsDist
 * @x: a #NcmVector
 * @rng: a #NcmRNG
 *
 * Using the pseudo-random number generator @rng generates a
 * point from the distribution and copy it to @x.
 *
 */
void
ncm_stats_dist_sample (NcmStatsDist *sd, NcmVector *x, NcmRNG *rng)
{
  NcmStatsDistPrivate * const self = sd->priv;
  const guint n                    = ncm_vector_len (self->weights);
  gint i;
  
  g_array_set_size (self->sampling, ncm_vector_len (self->weights));
  gsl_ran_multinomial (rng->r, n, 1, ncm_vector_data (self->weights), (guint *) self->sampling->data);
  
  for (i = 0; i < n; i++)
  {
    if (g_array_index (self->sampling, guint, i) > 0)
    {
      NcmVector *x_i = g_ptr_array_index (self->sample_array, i);
      
      ncm_stats_dist_kernel_sample (self->kernel,
                                    ncm_stats_dist_peek_cov_decomp (sd, i),
                                    self->href, x_i, x, rng);
      break;
    }
  }
}

/**
 * ncm_stats_dist_get_rnorm:
 * @sd: a #NcmStatsDist
 *
 * Gets the value of the last $\chi^2$ fit obtained
 * when computing the interpolation through
 * ncm_stats_dist_prepare_interp().
 *
 * Returns: the value of the $\chi^2$.
 */
gdouble
ncm_stats_dist_get_rnorm (NcmStatsDist *sd)
{
  NcmStatsDistPrivate * const self = sd->priv;
  
  return self->rnorm * self->rnorm;
}

/**
 * ncm_stats_dist_add_obs:
 * @sd: a #NcmStatsDist
 * @y: a #NcmVector
 *
 * Adds a new point @y to the sample with weight 1.0.
 *
 */
void
ncm_stats_dist_add_obs (NcmStatsDist *sd, NcmVector *x)
{
  NcmStatsDistPrivate * const self = sd->priv;
  
  g_ptr_array_add (self->sample_array, ncm_vector_dup (x));
}

/**
 * ncm_stats_dist_peek_sample_array:
 * @sd: a #NcmStatsDist
 *
 * Returns: (transfer none) (element-type NcmVector): current sample array.
 */
GPtrArray *
ncm_stats_dist_peek_sample_array (NcmStatsDist *sd)
{
  NcmStatsDistPrivate * const self = sd->priv;
  
  return self->sample_array;
}

/**
 * ncm_stats_dist_peek_cov_decomp: (virtual peek_cov_decomp)
 * @sd: a #NcmStatsDist
 * @i: kernel index
 *
 * Gets the covariance matrix associated with the @i-th
 * kernel.
 *
 * Returns: (transfer none): Cholesky decomposition of the @i-th covariance matrix.
 */
NcmMatrix *
ncm_stats_dist_peek_cov_decomp (NcmStatsDist *sd, guint i)
{
  NcmStatsDistClass *sd_class = NCM_STATS_DIST_GET_CLASS (sd);
  
  return sd_class->peek_cov_decomp (sd, i);
}

/**
 * ncm_stats_dist_get_lnnorm: (virtual get_lnnorm)
 * @sd: a #NcmStatsDist
 * @i: kernel index
 *
 * Gets the logarithm of the @i-th kernel normalization.
 *
 * Returns: $\ln (N_i)$.
 */
gdouble
ncm_stats_dist_get_lnnorm (NcmStatsDist *sd, guint i)
{
  NcmStatsDistClass *sd_class = NCM_STATS_DIST_GET_CLASS (sd);
  
  return sd_class->get_lnnorm (sd, i);
}

/**
 * ncm_stats_dist_peek_weights:
 * @sd: a #NcmStatsDist
 *
 * Returns: (transfer none): current weights vector.
 */
NcmVector *
ncm_stats_dist_peek_weights (NcmStatsDist *sd)
{
  NcmStatsDistPrivate * const self = sd->priv;
  
  return self->weights;
}

/**
 * ncm_stats_dist_reset: (virtual reset)
 * @sd: a #NcmStatsDist
 *
 * Reset the object discarding all added points.
 *
 */
void
ncm_stats_dist_reset (NcmStatsDist *sd)
{
  NcmStatsDistClass *sd_class = NCM_STATS_DIST_GET_CLASS (sd);
  
  sd_class->reset (sd);
}

/**
 * ncm_stats_dist_get_Ki:
 * @sd: a #NcmStatsDist
 * @i: kernel index
 * @y_i: (out callee-allocates) (transfer full): kernel location
 * @cov_i: (out callee-allocates) (transfer full): kernel covariance U
 * @n_i: (out): kernel normalization
 * @w_i: (out): kernel weight
 *
 * Return all information about the @i-th kernel.
 *
 */
void
ncm_stats_dist_get_Ki (NcmStatsDist *sd, const guint i, NcmVector **y_i, NcmMatrix **cov_i, gdouble *n_i, gdouble *w_i)
{
  NcmStatsDistPrivate * const self = sd->priv;
  NcmMatrix *cov_decomp            = ncm_stats_dist_peek_cov_decomp (sd, i);
  const gdouble lnnorm             = ncm_stats_dist_get_lnnorm (sd, i);
  
  g_assert (i < ncm_stats_dist_get_sample_size (sd));
  
  y_i[0]   = ncm_vector_dup (g_ptr_array_index (self->sample_array, i));
  cov_i[0] = ncm_matrix_dup (cov_decomp);
  n_i[0]   = exp (lnnorm + self->d * log (self->href));
  w_i[0]   = ncm_vector_get (self->weights, i);
  
  ncm_matrix_triang_to_sym (cov_decomp, 'U', TRUE, cov_i[0]);
  
  ncm_matrix_scale (cov_i[0], self->href * self->href);
}

