/* -*- Mode: C; indent-tabs-mode: nil; c-basic-offset: 2; tab-width: 2 -*-  */

/***************************************************************************
 *            ncm_stats_dist_kernel_st.c
 *
 *  Wed November 07 17:41:47 2018
 *  Copyright  2018  Sandro Dias Pinto Vitenti
 *  <sandro@isoftware.com.br>
 ****************************************************************************/
/*
 * ncm_stats_dist_kernel_st.c
 * Copyright (C) 2018 Sandro Dias Pinto Vitenti <sandro@isoftware.com.br>
 *
 * numcosmo is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * numcosmo is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * SECTION:ncm_stats_dist_kernel_st
 * @title: NcmStatsDistKernelST
 * @short_description: An N dimensional probability distributions using Multivariate Student's t VBK
 *
 * This object provides the tools to perform a radial basis interpolation
 * in a multidimensional function, using a multivariate Student's t distribution.
 * The goal is to use a polinomial function generated by the interpolation,
 * such that we are able to sample the original functio from this new interpolation function.
 * For more informations about radial basis interpolation,
 * check #NcmStatsDistNd.
 * A brief description of the Multivariate Studentt function can be found below.
 * For more information, check [[The R Journal Vol. 5/2, December 2013](https://journal.r-project.org/archive/2013/RJ-2013-033/RJ-2013-033.pdf)]
 *
 * We use the Multivariate Student's t function as the radial basis function. The function has the stocastic representation given by
 *
 * \begin{align}
 * \boldsymbol{X}=\boldsymbol{\mu}+\sqrt{W} A \boldsymbol{Z}
 * ,\end{align}
 * where $W= \nu / \chi_{\nu}^{2}$, $\nu$ represents the degree of freedom of a chi-squared distribution $\chi_{\nu}^2$,
 * $\boldsymbol{Z}$ is a p-dimensional random vector, $A$ is a $p \times p$ matrix and $\mu$ is the mean vector.
 *
 * $\boldsymbol{X}$ is fully determined by the covariance matrix $\Sigma = \boldsymbol{A}\boldsymbol{A}^t$ and the mean vector $\mu$.
 * Assuming that the covariance matrix is positive definite, $\boldsymbol{X}$ has the probability density
 *
 * \begin{align}
 * \phi(x) &= \frac{\Gamma[(\nu+p) / 2]}{\Gamma(\nu / 2) \nu^{p / 2} \pi^{p / 2}|\mathbf{\Sigma}|^{1 / 2}}\left[1+\frac{1}{\nu}
 * (\mathbf{x}-\boldsymbol{\mu})^{T} \boldsymbol{\Sigma}^{-1}(\mathbf{x}-\boldsymbol{\mu})\right]^{-(\nu+p) / 2},
 * \end{align}
 * where $p$ is the dimension and $x$ are the points to be evaluated.
 *
 * Once this object is initialized, we may use the methods in the #NcmStasDistNd class to perform the interpolation
 * and to generate a sample from the interpolated polinomal function.
 *
 * The user must provide the following input values: $p$ - ncm_stats_dist_kernel_st_new(),
 * cv_type - ncm_stats_dist_kernel_st_new(), $\nu$ - ncm_stats_dist_kernel_st_new().
 *
 */

#ifdef HAVE_CONFIG_H
#  include "config.h"
#endif /* HAVE_CONFIG_H */
#include "build_cfg.h"

#include "gsl/gsl_sf_result.h"

#include "math/ncm_stats_dist_kernel_st.h"
#include "math/ncm_stats_vec.h"
#include "math/ncm_c.h"
#include "math/ncm_lapack.h"

#ifndef NUMCOSMO_GIR_SCAN
#include <gsl/gsl_blas.h>
#include <gsl/gsl_min.h>
#include <gsl/gsl_sf_gamma.h>
#include "levmar/levmar.h"
#endif /* NUMCOSMO_GIR_SCAN */

struct _NcmStatsDistKernelSTPrivate
{
  gdouble nu;
};

enum
{
  PROP_0,
  PROP_NU,
};

G_DEFINE_TYPE_WITH_PRIVATE (NcmStatsDistKernelST, ncm_stats_dist_kernel_st, NCM_TYPE_STATS_DIST_KERNEL);

static void
ncm_stats_dist_kernel_st_init (NcmStatsDistKernelST *sdkst)
{
  NcmStatsDistKernelSTPrivate * const self = sdkst->priv = ncm_stats_dist_kernel_st_get_instance_private (sdkst);
  
  printf ("AQUI?\n");fflush (stdout);
  self->nu = 0.0;
}

static void
_ncm_stats_dist_kernel_st_set_property (GObject *object, guint prop_id, const GValue *value, GParamSpec *pspec)
{
  NcmStatsDistKernelST *sdkst = NCM_STATS_DIST_KERNEL_ST (object);
  
  /*NcmStatsDistKernelSTPrivate * const self = sdkst->priv;*/
  printf ("AQUI?1\n");fflush (stdout);
  g_return_if_fail (NCM_IS_STATS_DIST_KERNEL_ST (object));
  
  switch (prop_id)
  {
    case PROP_NU:
      ncm_stats_dist_kernel_st_set_nu (sdkst, g_value_get_double (value));
      break;
    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
      break;
  }
}

static void
_ncm_stats_dist_kernel_st_get_property (GObject *object, guint prop_id, GValue *value, GParamSpec *pspec)
{
  NcmStatsDistKernelST *sdkst = NCM_STATS_DIST_KERNEL_ST (object);
  
  /*NcmStatsDistKernelSTPrivate * const self = sdkst->priv;*/
  printf ("AQUI?2\n");fflush (stdout);
  g_return_if_fail (NCM_IS_STATS_DIST_KERNEL_ST (object));
  
  switch (prop_id)
  {
    case PROP_NU:
      g_value_set_double (value, ncm_stats_dist_kernel_st_get_nu (sdkst));
      break;
    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
      break;
  }
}

static void
_ncm_stats_dist_kernel_st_dispose (GObject *object)
{
  /*NcmStatsDistKernelST *sdkst               = NCM_STATS_DIST_KERNEL_ST (object);*/
  /*NcmStatsDistKernelSTPrivate * const self = sdkst->priv;*/
  
  /* Chain up : end */
  G_OBJECT_CLASS (ncm_stats_dist_kernel_st_parent_class)->dispose (object);
}

static void
_ncm_stats_dist_kernel_st_finalize (GObject *object)
{
  /* Chain up : end */
  G_OBJECT_CLASS (ncm_stats_dist_kernel_st_parent_class)->finalize (object);
}

static gdouble _ncm_stats_dist_kernel_st_get_rot_bandwidth (NcmStatsDistKernel *sdk, const gdouble n);
static gdouble _ncm_stats_dist_kernel_st_get_lnnorm (NcmStatsDistKernel *sdk, NcmMatrix *cov_decomp, const gdouble href);

static void
ncm_stats_dist_kernel_st_class_init (NcmStatsDistKernelSTClass *klass)
{
  GObjectClass *object_class         = G_OBJECT_CLASS (klass);
  NcmStatsDistKernelClass *sdk_class = NCM_STATS_DIST_KERNEL_CLASS (klass);
  
  object_class->set_property = &_ncm_stats_dist_kernel_st_set_property;
  object_class->get_property = &_ncm_stats_dist_kernel_st_get_property;
  object_class->dispose      = &_ncm_stats_dist_kernel_st_dispose;
  object_class->finalize     = &_ncm_stats_dist_kernel_st_finalize;
  
  g_object_class_install_property (object_class,
                                   PROP_NU,
                                   g_param_spec_double ("nu",
                                                        NULL,
                                                        "nu value of the function",
                                                        1.0, G_MAXDOUBLE, 3.0,
                                                        G_PARAM_READWRITE | G_PARAM_STATIC_NAME | G_PARAM_STATIC_BLURB));
  
  sdk_class->get_rot_bandwidth = &_ncm_stats_dist_kernel_st_get_rot_bandwidth;
  sdk_class->get_lnnorm        = &_ncm_stats_dist_kernel_st_get_lnnorm;
}

static gdouble
_ncm_stats_dist_kernel_st_f (NcmStatsDistKernelSTPrivate * const self, const guint d, gdouble chi2)
{
  return pow (1.0 + chi2 / self->nu, -0.5 * (self->nu + d));
}

static gdouble
_ncm_stats_dist_kernel_st_get_rot_bandwidth (NcmStatsDistKernel *sdk, const gdouble n)
{
  NcmStatsDistKernelST *sdkst              = NCM_STATS_DIST_KERNEL_ST (sdk);
  NcmStatsDistKernelSTPrivate * const self = sdkst->priv;
  
  const guint d    = ncm_stats_dist_kernel_get_dim (sdk);
  const gdouble nu = (self->nu >= 3.0) ? self->nu : 3.0;
  
  return pow (
    16.0 * gsl_pow_2 (nu - 2) * (1.0 + d + nu) * (3.0 + d + nu) /
    ((2.0 + d) * (d + nu) * (2.0 + d + nu) * (d + 2.0 * nu) * (2.0 + d + 2.0 * nu) * n),
    1.0 / (d + 4.0));
}

static gdouble
_ncm_stats_dist_kernel_st_get_lnnorm (NcmStatsDistKernel *sdk, NcmMatrix *cov_decomp, const gdouble href)
{
  NcmStatsDistKernelST *sdkst              = NCM_STATS_DIST_KERNEL_ST (sdk);
  NcmStatsDistKernelSTPrivate * const self = sdkst->priv;
  
  const guint d             = ncm_stats_dist_kernel_get_dim (sdk);
  const gdouble lg_lnnorm   = lgamma (self->nu / 2.0) - lgamma ((self->nu + d) / 2.0);
  const gdouble chol_lnnorm = 0.5 * ncm_matrix_cholesky_lndet (cov_decomp);
  const gdouble nc_lnnorm   = (d / 2.0) * (ncm_c_lnpi () + log (self->nu));
  
  return lg_lnnorm + nc_lnnorm + chol_lnnorm + d * log (href);
}

static void
_ncm_stats_dist_kernel_st_prepare_IM (NcmStatsDistKernelST *sdk, GPtrArray *Us, const gint d, const gint n, const NcmVector *href, NcmMatrix *IM, GPtrArray *sample_array, GArray *lnnorm_array)
{
  NcmStatsDistKernelST *sdkst = NCM_STATS_DIST_KERNEL_ST (sdk);
  NcmStatsDistKernelSTPrivate * const self = sdkst->priv;
  NcmVector *delta_ij = ncm_vector_new (d);
  gint i, j, res;
  
  for (i = 0; i < n; i++)
  {
    NcmMatrix *cov_decomp_i = g_ptr_array_index (Us, i);
    NcmVector *theta_i      = g_ptr_array_index (sample_array, i);
    gdouble norm_i          = exp (g_array_index (lnnorm_array, gdouble, i));
    
    for (j = 0; j < n; j++)
    {
      NcmVector *theta_j = g_ptr_array_index (sample_array, j);
      gdouble m2lnp_ij   = 0.0;
      gdouble p_ij;
      gint k;
      
      ncm_vector_memcpy (delta_ij, theta_i);
      ncm_vector_sub (delta_ij, theta_j);
      
      res = gsl_blas_dtrsv (CblasUpper, CblasTrans, CblasNonUnit, ncm_matrix_gsl (cov_decomp_i), ncm_vector_gsl (delta_ij));
      NCM_TEST_GSL_RESULT ("ncm_stats_dist_nd_vbk_prepare_IM", res);
      
      for (k = 0; k < d; k++)
      {
        m2lnp_ij += gsl_pow_2 (ncm_vector_fast_get (delta_ij, k) / ncm_vector_fast_get (href, k));
      }
      
      p_ij = _ncm_stats_dist_kernel_st_f (self, d, m2lnp_ij) / norm_i;
      
      ncm_matrix_set (IM, j, i, p_ij);
    }
  }
  
  ncm_vector_free (delta_ij);
}

static gdouble
_ncm_stats_dist_kernel_st_eval (NcmStatsDistKernelST *sdk, NcmVector *weights, NcmVector *y, GPtrArray *sample_array, const gint d, const gint n, const NcmVector *href, GPtrArray *cov_array, GArray *lnnorm_array)
{
  NcmStatsDistKernelST *sdkst = NCM_STATS_DIST_KERNEL_ST (sdk);
  NcmStatsDistKernelSTPrivate * const self = sdkst->priv;
  gdouble s = 0.0;
  gdouble c = 0.0;
  gint i, ret;
  NcmVector *delta_i = ncm_vector_new (d);
  
  for (i = 0; i < n; i++)
  {
    NcmMatrix *cov_decomp_i = g_ptr_array_index (cov_array, i);
    NcmVector *theta_i = g_ptr_array_index (sample_array, i);
    gdouble norm_i = exp (g_array_index (lnnorm_array, gdouble, i));
    gdouble e_i, t, chi2_i = 0.0;
    gint k;
    
    ncm_vector_memcpy (delta_i, y);
    ncm_vector_sub (delta_i, theta_i);
    
    ret = gsl_blas_dtrsv (CblasUpper, CblasTrans, CblasNonUnit, ncm_matrix_gsl (cov_decomp_i), ncm_vector_gsl (delta_i));
    NCM_TEST_GSL_RESULT ("_ncm_stats_dist_kernel_st_eval", ret);
    
    for (k = 0; k < d; k++)
    {
      chi2_i += gsl_pow_2 (ncm_vector_fast_get (delta_i, k) / ncm_vector_fast_get (href, k));
    }
    
    e_i =  ncm_vector_get (weights, i) * _ncm_stats_dist_kernel_st_f (self, d, chi2_i) / norm_i;
    t   = s + e_i;
    c  += (s >= e_i) ? ((s - t) + e_i) : ((e_i - t) + s);
    s   = t;
  }
  
  ncm_vector_free (delta_i);
  
  return s;
}

static void
_ncm_stats_dist_kernel_st_kernel_sample (NcmStatsDistKernelST *sdk, NcmMatrix *cov_decomp, const guint d, NcmVector *y, NcmVector *mu, const NcmVector *href, NcmRNG *rng)
{
  NcmStatsDistKernelST *sdkst              = NCM_STATS_DIST_KERNEL_ST (sdk);
  NcmStatsDistKernelSTPrivate * const self = sdkst->priv;
  gdouble chi_scale;
  gint i, ret;
  
  for (i = 0; i < d; i++)
  {
    const gdouble u_i = gsl_ran_ugaussian (rng->r);
    
    ncm_vector_set (y, i, u_i * ncm_vector_fast_get (href, i));
  }
  
  /* CblasLower, CblasNoTrans => CblasUpper, CblasTrans */
  ret = gsl_blas_dtrmv (CblasUpper, CblasTrans, CblasNonUnit,
                        ncm_matrix_gsl (cov_decomp), ncm_vector_gsl (y));
  NCM_TEST_GSL_RESULT ("ncm_stats_dist_kernel_st_sample_mean_scale", ret);
  
  chi_scale = sqrt (self->nu / gsl_ran_chisq (rng->r, self->nu));
  
  ncm_vector_scale (y, chi_scale);
  ncm_vector_add (y, mu);
}

static gdouble
_ncm_stats_dist_kernel_st_kernel_eval_m2lnp (NcmStatsDistKernelST *sdk, NcmMatrix *cov_decomp, const guint d, NcmVector *x, NcmVector *y, NcmVector *v, const NcmVector *href)
{
  NcmStatsDistKernelST *sdkst              = NCM_STATS_DIST_KERNEL_ST (sdk);
  NcmStatsDistKernelSTPrivate * const self = sdkst->priv;
  gdouble m2lnp;
  gint ret;
  
  ncm_vector_memcpy (v, x);
  ncm_vector_sub (v, y);
  
  ret = gsl_blas_dtrsv (CblasUpper, CblasTrans, CblasNonUnit,
                        ncm_matrix_gsl (cov_decomp), ncm_vector_gsl (v));
  NCM_TEST_GSL_RESULT ("_ncm_stats_dist_kernel_st_kernel_eval_m2lnp", ret);
  
  ncm_vector_div (v, href);
  
  ret = gsl_blas_ddot (ncm_vector_gsl (v), ncm_vector_gsl (v), &m2lnp);
  NCM_TEST_GSL_RESULT ("_ncm_stats_dist_kernel_st_kernel_eval_m2lnp", ret);
  
  return (self->nu + d) * log1p (m2lnp);
}

/**
 * ncm_stats_dist_kernel_st_new:
 * @dim: sample space dimension
 * @nu: Student-t parameter $\nu$
 *
 * Creates a new #NcmStatsDistKernelST object with sample dimension @dim
 * and $\nu$ = @nu.
 *
 * Returns: a new #NcmStatsDistKernelST.
 */
NcmStatsDistKernelST *
ncm_stats_dist_kernel_st_new (const guint dim, const gdouble nu)
{
  NcmStatsDistKernelST *sdkst = g_object_new (NCM_TYPE_STATS_DIST_KERNEL_ST,
                                              "dimension", dim,
                                              "nu",        nu,
                                              NULL);
  
  return sdkst;
}

/**
 * ncm_stats_dist_kernel_st_ref:
 * @sdkst: a #NcmStatsDistKernelST
 *
 * Increase the reference of @stats_dist_kernel_st by one.
 *
 * Returns: (transfer full): @stats_dist_kernel_st.
 */
NcmStatsDistKernelST *
ncm_stats_dist_kernel_st_ref (NcmStatsDistKernelST *sdkst)
{
  return g_object_ref (sdkst);
}

/**
 * ncm_stats_dist_kernel_st_free:
 * @sdkst: a #NcmStatsDistKernelST
 *
 * Decrease the reference count of @stats_dist_kernel_st by one.
 *
 */
void
ncm_stats_dist_kernel_st_free (NcmStatsDistKernelST *sdkst)
{
  g_object_unref (sdkst);
}

/**
 * ncm_stats_dist_kernel_st_clear:
 * @sdkst: a #NcmStatsDistKernelST
 *
 * Decrease the reference count of @stats_dist_kernel_st by one, and sets the pointer *@stats_dist_kernel_st to
 * NULL.
 *
 */
void
ncm_stats_dist_kernel_st_clear (NcmStatsDistKernelST **sdkst)
{
  g_clear_object (sdkst);
}

/**
 * ncm_stats_dist_kernel_st_set_nu:
 * @sdkst: a #NcmStatsDistKernelST
 * @nu: the over-smooth factor
 *
 * Sets the over-smooth factor to @nu.
 *
 */
void
ncm_stats_dist_kernel_st_set_nu (NcmStatsDistKernelST *sdkst, const gdouble nu)
{
  NcmStatsDistKernelSTPrivate * const self = sdkst->priv;
  
  self->nu = nu;
}

/**
 * ncm_stats_dist_kernel_st_get_nu:
 * @sdkst: a #NcmStatsDistKernelST
 *
 * Returns: the over-smooth factor.
 */
gdouble
ncm_stats_dist_kernel_st_get_nu (NcmStatsDistKernelST *sdkst)
{
  NcmStatsDistKernelSTPrivate * const self = sdkst->priv;
  
  return self->nu;
}

